---
phase: 03-sellercloud-integration-demand-visibility
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - src/server/api/routers/demand.ts
  - src/server/api/routers/alerts.ts
  - src/server/api/root.ts
autonomous: true

must_haves:
  truths:
    - "Cross-brand demand summary returns forecasted vs ordered vs on-hand vs in-transit per brand per month"
    - "Retailer breakdown returns demand per retailer across all brands for a given month"
    - "SKU-level drill-down returns demand, ordered, available, in-transit, and balance for every SKU"
    - "Shortage alerts flag SKUs where forecasted demand exceeds ordered + available inventory"
    - "Excess alerts flag SKUs where ordered/available significantly exceeds forecasted demand"
    - "All three new routers (sellercloud, demand, alerts) are registered in appRouter"
  artifacts:
    - path: "src/server/api/routers/demand.ts"
      provides: "crossBrandSummary, retailerBreakdown, skuDrillDown procedures"
      min_lines: 100
    - path: "src/server/api/routers/alerts.ts"
      provides: "shortages, excesses procedures with calculation logic"
      min_lines: 60
    - path: "src/server/api/root.ts"
      provides: "All routers registered including sellercloud, demand, alerts"
      contains: "sellercloud.*demand.*alerts"
  key_links:
    - from: "src/server/api/routers/demand.ts"
      to: "src/server/db/schema.ts"
      via: "Drizzle SQL aggregations with JOINs"
      pattern: "sql.*sum|groupBy"
    - from: "src/server/api/routers/alerts.ts"
      to: "src/server/db/schema.ts"
      via: "Inventory balance queries"
      pattern: "forecasts.*inventory|calculateShortage|calculateExcess"
    - from: "src/server/api/root.ts"
      to: "demand|alerts|sellercloud"
      via: "router registration"
      pattern: "demand.*demandRouter|alerts.*alertsRouter|sellercloud.*sellercloudRouter"
---

<objective>
Build the demand aggregation and alert calculation backend: tRPC routers that compute cross-brand summaries, retailer breakdowns, SKU-level drill-downs, and shortage/excess alerts using PostgreSQL aggregations. Also register all three new Phase 3 routers (sellercloud from Plan 01, demand, alerts) in appRouter.

Purpose: Powers all demand visibility dashboards (DEM-01 through DEM-05) with server-side calculations. These routers provide the data layer that Plan 03 and 04 UI components consume.
Output: demand tRPC router with 4 query procedures, alerts tRPC router with 3 query procedures, all Phase 3 routers registered in appRouter.
</objective>

<execution_context>
@/Users/kaaba/.claude/get-shit-done/workflows/execute-plan.md
@/Users/kaaba/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-sellercloud-integration-demand-visibility/03-RESEARCH.md
@.planning/phases/03-sellercloud-integration-demand-visibility/03-01-SUMMARY.md
@src/server/db/schema.ts
@src/server/api/root.ts
@src/server/api/trpc.ts
@src/server/api/routers/import.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Demand aggregation tRPC router</name>
  <files>
    src/server/api/routers/demand.ts
  </files>
  <action>
Create `src/server/api/routers/demand.ts` with the following procedures. All queries use PostgreSQL-level aggregation (Drizzle `sql` template), NOT client-side array reduces.

1. `crossBrandSummary` query (protectedProcedure):
   - Input: `{ monthStart: z.date(), monthEnd: z.date(), brandId: z.number().optional() }`
   - Query:
     - SELECT brands.id, brands.name, forecasts.month, SUM(forecasts.forecastedUnits), SUM(forecasts.orderedUnits)
     - LEFT JOIN inventory on skus.id to get SUM(COALESCE(inventory.quantityOnHand, 0)), SUM(COALESCE(inventory.quantityInTransit, 0)), SUM(COALESCE(inventory.quantityAllocated, 0))
     - FROM forecasts INNER JOIN skus ON skuId INNER JOIN brands ON brandId
     - LEFT JOIN inventory ON skus.id = inventory.skuId
     - WHERE month BETWEEN monthStart AND monthEnd, optional brandId filter
     - GROUP BY brands.id, brands.name, forecasts.month
     - ORDER BY forecasts.month ASC, brands.name ASC
   - Return shape: `{ brandId, brandName, month, forecastedUnits, orderedUnits, onHandUnits, inTransitUnits, allocatedUnits }[]`
   - Calculate derived fields in the return map: `availableUnits = onHandUnits + inTransitUnits - allocatedUnits`, `balance = orderedUnits + availableUnits - forecastedUnits`
   - Cast SQL sum results to number (they return as string from pg)

2. `retailerBreakdown` query (protectedProcedure):
   - Input: `{ month: z.date(), brandId: z.number().optional() }`
   - Query:
     - SELECT retailers.id, retailers.name, brands.id, brands.name, SUM(forecasts.forecastedUnits), SUM(forecasts.orderedUnits)
     - FROM forecasts INNER JOIN skus, brands, retailers
     - WHERE month = input.month, optional brandId filter
     - GROUP BY retailers.id, retailers.name, brands.id, brands.name
     - ORDER BY retailers.name ASC, brands.name ASC
   - Return shape: `{ retailerId, retailerName, brandId, brandName, forecastedUnits, orderedUnits }[]`

3. `skuDrillDown` query (protectedProcedure):
   - Input: `{ month: z.date(), brandId: z.number().optional(), retailerId: z.number().optional(), limit: z.number().default(200), offset: z.number().default(0) }`
   - Query:
     - SELECT skus.id, skus.sku, skus.name as skuName, brands.name as brandName, forecasts.month,
       SUM(forecasts.forecastedUnits), SUM(forecasts.orderedUnits),
       COALESCE(inventory.quantityOnHand, 0), COALESCE(inventory.quantityInTransit, 0), COALESCE(inventory.quantityAllocated, 0)
     - FROM forecasts INNER JOIN skus, brands LEFT JOIN inventory
     - WHERE month = input.month, optional brandId/retailerId filters
     - GROUP BY skus.id, skus.sku, skus.name, brands.name, forecasts.month, inventory columns
     - ORDER BY skus.sku ASC
     - LIMIT/OFFSET for pagination
   - Calculate derived fields: `available = onHand + inTransit - allocated`, `shortage = max(0, forecasted - ordered - available)`, `excess` using threshold logic (supply/forecast ratio > 2.0)
   - Return shape: `{ skuId, sku, skuName, brandName, month, forecastedUnits, orderedUnits, onHandUnits, inTransitUnits, allocatedUnits, availableUnits, shortage, excess }[]`
   - Also return `totalCount` for pagination

4. `monthlySummary` query (protectedProcedure):
   - Input: `{ brandId: z.number().optional() }`
   - Returns aggregated totals for the current month and next 3 months
   - For each month: total forecasted, total ordered, total available
   - Useful for executive summary sparkline/trend data
   - Use `startOfMonth`, `addMonths`, `eachMonthOfInterval` from date-fns to generate the month range (current month through +3 months)

Important: All `sql<number>` template results from Drizzle come back as strings from PostgreSQL. Map results and use `Number()` to convert. Handle null/undefined with `?? 0` fallback.
  </action>
  <verify>
Run `npx tsc --noEmit` to confirm TypeScript compiles. Verify demand.ts exports `demandRouter` with 4 procedures. Verify all queries use SQL-level aggregation (grep for `sql` and `groupBy` in the file).
  </verify>
  <done>
Demand router exists with crossBrandSummary, retailerBreakdown, skuDrillDown, and monthlySummary procedures. All aggregations happen in PostgreSQL via Drizzle SQL templates. Derived fields (available, shortage, excess) calculated correctly. Pagination supported on skuDrillDown.
  </done>
</task>

<task type="auto">
  <name>Task 2: Alerts tRPC router and register all Phase 3 routers</name>
  <files>
    src/server/api/routers/alerts.ts
    src/server/api/root.ts
  </files>
  <action>
Create `src/server/api/routers/alerts.ts`:

First, define calculation helper functions at the top of the file (exported for potential testing):

```typescript
export function calculateShortage(balance: {
  forecastedUnits: number;
  orderedUnits: number;
  onHandUnits: number;
  inTransitUnits: number;
  allocatedUnits: number;
}): number {
  const available = balance.onHandUnits + balance.inTransitUnits - balance.allocatedUnits;
  const shortage = balance.forecastedUnits - balance.orderedUnits - available;
  return Math.max(0, shortage);
}

export function calculateExcess(balance: {
  forecastedUnits: number;
  orderedUnits: number;
  onHandUnits: number;
  inTransitUnits: number;
  allocatedUnits: number;
}, threshold = 2.0): number {
  const available = balance.onHandUnits + balance.inTransitUnits - balance.allocatedUnits;
  const supply = balance.orderedUnits + available;
  if (balance.forecastedUnits === 0) {
    return supply > 0 ? supply : 0;
  }
  const ratio = supply / balance.forecastedUnits;
  return ratio > threshold ? Math.round(supply - balance.forecastedUnits * threshold) : 0;
}
```

Then define the router with these procedures:

1. `shortages` query (protectedProcedure):
   - Input: `{ brandId: z.number().optional(), month: z.date().optional(), minShortage: z.number().default(0), limit: z.number().default(50) }`
   - Default month to current month start (use `startOfMonth(new Date())` from date-fns)
   - Query: Join forecasts + skus + brands + inventory (LEFT JOIN), group by SKU
   - Sum forecastedUnits, orderedUnits per SKU for the given month
   - Get inventory values (onHand, inTransit, allocated)
   - Apply `calculateShortage()` to each row
   - Filter to only rows where shortage > minShortage
   - Sort by shortage DESC (highest shortage first)
   - Limit results
   - Return: `{ skuId, sku, skuName, brandName, brandId, forecastedUnits, orderedUnits, onHandUnits, inTransitUnits, allocatedUnits, availableUnits, shortage }[]`

2. `excesses` query (protectedProcedure):
   - Input: `{ brandId: z.number().optional(), month: z.date().optional(), threshold: z.number().default(2.0), limit: z.number().default(50) }`
   - Same query pattern as shortages but apply `calculateExcess()` with threshold
   - Filter to only rows where excess > 0
   - Sort by excess DESC
   - Return: `{ skuId, sku, skuName, brandName, brandId, forecastedUnits, orderedUnits, supply, excess, ratio }[]`
   - Include `ratio` (supply/forecast) for context

3. `summary` query (protectedProcedure):
   - Input: `{ brandId: z.number().optional() }`
   - Returns: `{ totalShortageSkus: number, totalExcessSkus: number, topShortages: top3[], topExcesses: top3[], totalShortageUnits: number, totalExcessUnits: number }`
   - This is the compact alert summary for the executive dashboard

Then update `src/server/api/root.ts` to register ALL three new Phase 3 routers:
- Import `sellercloudRouter` from `./routers/sellercloud` (created by Plan 01)
- Import `demandRouter` from `./routers/demand`
- Import `alertsRouter` from `./routers/alerts`
- Add to appRouter: `sellercloud: sellercloudRouter`, `demand: demandRouter`, `alerts: alertsRouter`
- Keep all existing router registrations (brands, skus, retailers, audit, import, orders) intact
  </action>
  <verify>
Run `npx tsc --noEmit` to confirm TypeScript compiles. Verify root.ts now has sellercloud, demand, and alerts routers (9 total routers). Verify alerts.ts exports calculateShortage, calculateExcess, and alertsRouter. Run `npm run build` to confirm full build passes.
  </verify>
  <done>
Alerts router exists with shortages, excesses, and summary procedures. Calculation functions exported and use standardized formulas (Available = OnHand + InTransit - Allocated; Shortage = Forecasted - Ordered - Available). All three Phase 3 routers (sellercloud, demand, alerts) registered in appRouter alongside existing routers. TypeScript compiles cleanly.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. `npm run build` succeeds
3. `src/server/api/routers/demand.ts` exports demandRouter with crossBrandSummary, retailerBreakdown, skuDrillDown, monthlySummary
4. `src/server/api/routers/alerts.ts` exports alertsRouter with shortages, excesses, summary
5. `src/server/api/routers/alerts.ts` exports calculateShortage and calculateExcess helper functions
6. `src/server/api/root.ts` includes sellercloud, demand, and alerts routers (9 total)
7. All aggregations use PostgreSQL-level queries (not client-side reduce)
</verification>

<success_criteria>
- Cross-brand summary aggregates forecasted vs ordered vs available per brand per month
- Retailer breakdown shows per-retailer demand across brands
- SKU drill-down shows individual SKU balances with pagination
- Shortage alerts correctly flag SKUs where demand > supply
- Excess alerts correctly flag SKUs where supply >> demand (ratio > threshold)
- All calculations use standardized formulas from research
- All Phase 3 routers registered in appRouter
- TypeScript compiles cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/03-sellercloud-integration-demand-visibility/03-02-SUMMARY.md`
</output>
