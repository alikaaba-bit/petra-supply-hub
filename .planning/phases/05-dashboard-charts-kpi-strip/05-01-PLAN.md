---
phase: 05-dashboard-charts-kpi-strip
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/server/api/routers/dashboard.ts
  - src/server/api/root.ts
  - src/components/ui/chart.tsx
  - package.json
autonomous: true

must_haves:
  truths:
    - "shadcn/ui chart component is installed and available for import"
    - "dashboardRouter exposes revenueTrend, brandPerformance, retailerMix, and kpiSummary endpoints"
    - "All 4 endpoints return typed data from PostgreSQL aggregation, not client-side computation"
    - "dashboardRouter is registered in appRouter and accessible via trpc.dashboard.*"
  artifacts:
    - path: "src/components/ui/chart.tsx"
      provides: "ChartContainer, ChartTooltip, ChartTooltipContent, ChartConfig exports"
      contains: "ChartContainer"
    - path: "src/server/api/routers/dashboard.ts"
      provides: "dashboardRouter with 4 query endpoints"
      exports: ["dashboardRouter"]
    - path: "src/server/api/root.ts"
      provides: "Updated appRouter with dashboard router"
      contains: "dashboard: dashboardRouter"
  key_links:
    - from: "src/server/api/routers/dashboard.ts"
      to: "src/server/db/schema.ts"
      via: "Drizzle ORM queries on retailSales, brands, skus, retailers tables"
      pattern: "retailSales|brands|skus|retailers"
    - from: "src/server/api/root.ts"
      to: "src/server/api/routers/dashboard.ts"
      via: "import and register dashboardRouter"
      pattern: "dashboard: dashboardRouter"
---

<objective>
Install shadcn/ui chart components and create the dashboardRouter tRPC router with all 4 chart data endpoints needed for Phase 5 visualizations.

Purpose: Establish the data layer and chart component library so chart UI components (Plan 02) can consume typed data and render with consistent theming.
Output: A working chart.tsx UI component, a dashboardRouter with 4 endpoints returning aggregated chart data, and the router registered in appRouter.
</objective>

<execution_context>
@/Users/kaaba/.claude/get-shit-done/workflows/execute-plan.md
@/Users/kaaba/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-dashboard-charts-kpi-strip/05-RESEARCH.md

Key existing files to reference:
@src/server/api/routers/demand.ts — PostgreSQL aggregation pattern (CAST/COALESCE/SUM)
@src/server/api/routers/alerts.ts — alerts.summary endpoint pattern (for KPI open alerts)
@src/server/api/routers/orders.ts — orders.purchaseOrders.count endpoint (for KPI active POs)
@src/server/api/root.ts — Router registration pattern
@src/server/api/trpc.ts — protectedProcedure definition
@src/server/db/schema.ts — retailSales table definition (lines 231-264), brands, skus, retailers tables
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install shadcn/ui chart component</name>
  <files>src/components/ui/chart.tsx, package.json</files>
  <action>
    Run `pnpm dlx shadcn@latest add chart` to install the shadcn/ui chart component.

    This will:
    - Create `src/components/ui/chart.tsx` with ChartContainer, ChartTooltip, ChartTooltipContent, ChartConfig, ChartLegend, ChartLegendContent exports
    - Install `recharts` as a dependency in package.json

    After installation, verify the chart.tsx file exists and contains the expected exports. Verify recharts appears in package.json dependencies.

    If the CLI prompts for overwrite or confirmation, accept defaults. The project uses `new-york` style, `src/components/ui` alias, and CSS variables (all configured in components.json).
  </action>
  <verify>
    - `ls src/components/ui/chart.tsx` shows the file exists
    - `grep "recharts" package.json` shows recharts in dependencies
    - `grep "ChartContainer" src/components/ui/chart.tsx` confirms the component is present
  </verify>
  <done>chart.tsx exists in src/components/ui/ with all chart exports, and recharts is in package.json dependencies</done>
</task>

<task type="auto">
  <name>Task 2: Create dashboardRouter with 4 chart data endpoints</name>
  <files>src/server/api/routers/dashboard.ts, src/server/api/root.ts</files>
  <action>
    Create `src/server/api/routers/dashboard.ts` with a dashboardRouter containing 4 protectedProcedure query endpoints. Follow the exact same PostgreSQL aggregation pattern used in `demand.ts` (CAST/COALESCE/SUM as TEXT, then convert to Number).

    **Brand names in database:** Fomin, Luna Naturals, EveryMood, Roofus, House of Party

    **Endpoint 1: `revenueTrend`** (VIZ-01)
    - Input: `{ months: z.number().default(12) }`
    - Query: SELECT month, brandName, SUM(revenue) FROM retail_sales JOIN skus JOIN brands, GROUP BY month + brand, WHERE month >= (current month - input.months), ORDER BY month
    - Transform: Pivot from long format (one row per brand-month) to wide format for Recharts stacked area chart. Output shape: `{ month: "Feb 2026", "Fomin": 12345, "Luna Naturals": 6789, ... }[]`
    - Use `format(row.month, "MMM yyyy")` from date-fns for month labels
    - Use `startOfMonth(subMonths(new Date(), input.months))` for the date filter
    - Revenue column is `numeric(12,2)` so use `CAST(COALESCE(SUM(${retailSales.revenue}), 0) AS TEXT)` pattern

    **Endpoint 2: `brandPerformance`** (VIZ-02)
    - Input: none
    - Query: SELECT brandName, SUM(revenue) FROM retail_sales JOIN skus JOIN brands, GROUP BY brand, ORDER BY revenue DESC
    - Output shape: `{ brandName: string, revenue: number }[]`

    **Endpoint 3: `retailerMix`** (VIZ-03)
    - Input: none
    - Query: SELECT retailerName, brandName, SUM(revenue) FROM retail_sales JOIN skus JOIN brands JOIN retailers, GROUP BY retailer + brand, ORDER BY total retailer revenue DESC
    - Transform: Group into shape for horizontal stacked bar chart. Output: `{ retailerName: string, "Fomin": number, "Luna Naturals": number, ... }[]`
    - Use a Map to pivot: for each retailer, accumulate brand revenues into columns
    - Sort by total revenue descending (sum all brand values per retailer)

    **Endpoint 4: `kpiSummary`** (VIZ-04)
    - Input: none
    - Query Revenue MTD + Units Shipped MTD: SELECT SUM(revenue), SUM(units_sold) FROM retail_sales WHERE month = startOfMonth(new Date())
    - Query Open Alerts: Count shortage + excess SKUs using the same logic from alerts.ts summary (inline the calculation, do NOT use ctx.caller — it's not available in tRPC v11 routers). Query forecasts/inventory for current month, calculate shortage/excess counts in JS.
    - Query Active POs: SELECT COUNT(*) FROM purchase_orders (all POs, matching existing orders.purchaseOrders.count pattern)
    - Output shape: `{ revenueMTD: number, unitsShippedMTD: number, openAlerts: number, activePOs: number }`
    - Import `purchaseOrders` from schema for the PO count
    - Import `forecasts, inventory` from schema for alert count calculation
    - Reuse the `calculateShortage` and `calculateExcess` functions by importing from `@/server/api/routers/alerts` (they are exported)

    **Important implementation notes:**
    - Use `sql<string>` template literal type for all SUM aggregations (PostgreSQL returns strings for numeric types)
    - Convert all string results to Number() before returning
    - Import from: `drizzle-orm` (eq, gte, sql, count), `date-fns` (startOfMonth, subMonths, format), `../trpc` (router, protectedProcedure), `@/server/db/schema` (retailSales, skus, brands, retailers, purchaseOrders, forecasts, inventory)
    - Use `innerJoin` for skus/brands/retailers (every retail_sale must have these), `leftJoin` for inventory in KPI alert calc

    Then update `src/server/api/root.ts`:
    - Add import: `import { dashboardRouter } from "./routers/dashboard";`
    - Add to appRouter object: `dashboard: dashboardRouter,`
  </action>
  <verify>
    - `npx tsc --noEmit` passes without type errors
    - `grep "dashboardRouter" src/server/api/root.ts` confirms registration
    - `grep "revenueTrend\|brandPerformance\|retailerMix\|kpiSummary" src/server/api/routers/dashboard.ts` shows all 4 endpoints
  </verify>
  <done>dashboardRouter exists with 4 typed endpoints (revenueTrend, brandPerformance, retailerMix, kpiSummary), all using PostgreSQL aggregation, and is registered in appRouter. TypeScript compiles without errors.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` — no type errors in the project
2. `src/components/ui/chart.tsx` exists with ChartContainer export
3. `src/server/api/routers/dashboard.ts` exists with 4 endpoints
4. `src/server/api/root.ts` includes `dashboard: dashboardRouter`
5. `recharts` appears in package.json dependencies
</verification>

<success_criteria>
- shadcn/ui chart component installed and importable
- dashboardRouter with 4 endpoints compiles and is registered
- All endpoints use PostgreSQL-level aggregation (no client-side reduce on raw rows)
- revenueTrend and retailerMix return wide-format data ready for Recharts stacked charts
- kpiSummary returns all 4 KPI values (revenueMTD, unitsShippedMTD, openAlerts, activePOs)
</success_criteria>

<output>
After completion, create `.planning/phases/05-dashboard-charts-kpi-strip/05-01-SUMMARY.md`
</output>
