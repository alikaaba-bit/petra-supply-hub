---
phase: 01-foundation-master-data
plan: 02
title: "Authentication, tRPC API Layer & Audit Triggers"
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/server/auth.ts
  - auth.config.ts
  - src/app/api/auth/[...nextauth]/route.ts
  - src/server/api/trpc.ts
  - src/server/api/root.ts
  - src/server/api/routers/brands.ts
  - src/server/api/routers/skus.ts
  - src/server/api/routers/retailers.ts
  - src/server/api/routers/audit.ts
  - src/app/api/trpc/[trpc]/route.ts
  - src/lib/trpc.ts
  - src/components/providers.tsx
  - src/app/layout.tsx
  - src/app/(auth)/login/page.tsx
  - src/app/(auth)/layout.tsx
  - src/middleware.ts
  - src/types/next-auth.d.ts
  - drizzle/migrations/0001_audit_triggers.sql
autonomous: true

must_haves:
  truths:
    - "Users can log in with email and password via the /login page"
    - "Logged-in users are redirected to dashboard; unauthenticated users are redirected to /login"
    - "Session includes user role (ceo, sales, purchasing, warehouse)"
    - "tRPC procedures are callable from client components via the React Query integration"
    - "Protected tRPC procedures reject unauthenticated requests with UNAUTHORIZED error"
    - "PostgreSQL audit triggers fire on INSERT/UPDATE/DELETE for master data tables"
  artifacts:
    - path: "src/server/auth.ts"
      provides: "Auth.js v5 configuration with Credentials provider and role in session"
      contains: "NextAuth"
    - path: "src/server/api/trpc.ts"
      provides: "tRPC context, publicProcedure, protectedProcedure"
      contains: "initTRPC"
    - path: "src/server/api/root.ts"
      provides: "Root tRPC router combining all feature routers"
      contains: "appRouter"
    - path: "src/app/(auth)/login/page.tsx"
      provides: "Login form UI"
      contains: "signIn"
    - path: "drizzle/migrations/0001_audit_triggers.sql"
      provides: "PostgreSQL audit trigger function and trigger attachments"
      contains: "audit_trigger_func"
  key_links:
    - from: "src/server/api/trpc.ts"
      to: "src/server/auth.ts"
      via: "auth() call in createTRPCContext"
      pattern: "auth\\(\\)"
    - from: "src/app/api/trpc/[trpc]/route.ts"
      to: "src/server/api/root.ts"
      via: "appRouter handler"
      pattern: "appRouter"
    - from: "src/lib/trpc.ts"
      to: "src/server/api/root.ts"
      via: "AppRouter type export"
      pattern: "AppRouter"
    - from: "src/middleware.ts"
      to: "src/server/auth.ts"
      via: "auth middleware protecting dashboard routes"
      pattern: "auth|middleware"
---

# Plan 01-02: Authentication, tRPC API Layer & Audit Triggers

<objective>
Set up Auth.js v5 with Credentials provider and role-based sessions, configure tRPC v11 with protected procedures and feature routers for master data CRUD, create the login page, and install PostgreSQL audit triggers on master data tables.

Purpose: Authentication (FND-02) gates all dashboard access. tRPC provides the type-safe API layer for all data operations. Audit triggers (FND-04) ensure every data change is tracked at the database level.
Output: Working login flow, protected API routes, and database-level audit logging.
</objective>

<execution_context>
@/Users/kaaba/.claude/get-shit-done/workflows/execute-plan.md
@/Users/kaaba/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation-master-data/01-RESEARCH.md
@.planning/phases/01-foundation-master-data/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Auth.js v5 configuration with Credentials provider, role-based sessions, and login page</name>
  <files>
    src/server/auth.ts
    auth.config.ts
    src/app/api/auth/[...nextauth]/route.ts
    src/middleware.ts
    src/types/next-auth.d.ts
    src/app/(auth)/login/page.tsx
    src/app/(auth)/layout.tsx
  </files>
  <action>
  **1. Create `src/types/next-auth.d.ts`** — extend the Auth.js session and user types to include `role`:

  ```typescript
  import { DefaultSession, DefaultUser } from "next-auth";

  declare module "next-auth" {
    interface Session {
      user: {
        id: string;
        role: string;
      } & DefaultSession["user"];
    }

    interface User extends DefaultUser {
      role: string;
      passwordHash: string;
    }
  }
  ```

  **2. Create `src/server/auth.ts`** — Auth.js v5 configuration:

  - Use `NextAuth` from `next-auth`
  - Use `DrizzleAdapter` from `@auth/drizzle-adapter` with the `db` from `src/server/db`
  - Configure `Credentials` provider:
    - Fields: `email` (type: email), `password` (type: password)
    - In `authorize` function:
      1. Query `users` table for matching email where `active = true`
      2. Compare password using `bcryptjs.compare(password, user.passwordHash)`
      3. If valid, return `{ id: user.id, name: user.name, email: user.email, role: user.role }`
      4. If invalid, return `null`
  - Configure `callbacks`:
    - `jwt` callback: Add `role` and `id` to the JWT token from the user object (when `user` exists in the callback args, meaning it is a sign-in event)
    - `session` callback: Add `role` and `id` from `token` to `session.user`
  - Configure `session`: `{ strategy: "jwt" }` — IMPORTANT: Credentials provider requires JWT strategy, not database sessions.
  - Configure `pages`: `{ signIn: "/login" }`
  - Export `{ handlers, auth, signIn, signOut }` from `NextAuth(config)`

  IMPORTANT: Because we use the Credentials provider, we MUST use JWT strategy. The DrizzleAdapter is still used for the user/account model, but sessions are stored in JWT cookies, not the sessions table. This is a known Auth.js v5 pattern for Credentials.

  **3. Create `src/app/api/auth/[...nextauth]/route.ts`**:
  ```typescript
  import { handlers } from "@/server/auth";
  export const { GET, POST } = handlers;
  ```

  **4. Create `src/middleware.ts`** (NOT proxy.ts — check if Next.js 16 uses middleware.ts or proxy.ts; research says proxy.ts but this depends on the exact version installed; start with middleware.ts and if it doesn't work, rename to proxy.ts):

  - Import `auth` from `@/server/auth`
  - Use `auth` as middleware wrapper
  - Redirect unauthenticated users to `/login` when they access routes matching `/(dashboard)(.*)` pattern
  - Allow access to `/login`, `/api/auth`, and static assets without authentication
  - Use `config.matcher` to exclude `_next/static`, `_next/image`, `favicon.ico`, and API auth routes

  ```typescript
  export { auth as middleware } from "@/server/auth";

  export const config = {
    matcher: ["/((?!api/auth|_next/static|_next/image|favicon.ico|login).*)"],
  };
  ```

  NOTE: If the simple `export { auth as middleware }` pattern doesn't work with the middleware matcher to redirect to /login, implement a custom middleware function using `auth()` that checks the session and redirects:

  ```typescript
  import { auth } from "@/server/auth";
  import { NextResponse } from "next/server";

  export default auth((req) => {
    if (!req.auth && !req.nextUrl.pathname.startsWith("/login")) {
      return NextResponse.redirect(new URL("/login", req.url));
    }
  });

  export const config = {
    matcher: ["/((?!api/auth|_next/static|_next/image|favicon.ico).*)"],
  };
  ```

  **5. Create `src/app/(auth)/layout.tsx`** — minimal centered layout for auth pages:
  ```tsx
  export default function AuthLayout({ children }: { children: React.ReactNode }) {
    return (
      <div className="flex min-h-screen items-center justify-center bg-gray-50">
        <div className="w-full max-w-md">
          {children}
        </div>
      </div>
    );
  }
  ```

  **6. Create `src/app/(auth)/login/page.tsx`** — login form:

  Use shadcn/ui components: `Card`, `CardHeader`, `CardTitle`, `CardDescription`, `CardContent`, `CardFooter`, `Input`, `Label`, `Button`.

  The login page should:
  - Display "Petra Supply Hub" as the title
  - Show "Sign in to your account" as description
  - Have email input (type="email", required)
  - Have password input (type="password", required)
  - Have a "Sign In" submit button
  - Use a server action or client-side form that calls `signIn("credentials", { email, password, redirectTo: "/" })`
  - Show error message if login fails (use `useSearchParams` to check for `error` query param, or use client component with state)
  - Make it a client component (`"use client"`) for form state management

  Implementation:
  ```tsx
  "use client";

  import { useState } from "react";
  import { signIn } from "next-auth/react";
  import { useRouter } from "next/navigation";
  // Import shadcn/ui Card, Input, Label, Button components

  export default function LoginPage() {
    const [email, setEmail] = useState("");
    const [password, setPassword] = useState("");
    const [error, setError] = useState("");
    const [loading, setLoading] = useState(false);
    const router = useRouter();

    const handleSubmit = async (e: React.FormEvent) => {
      e.preventDefault();
      setLoading(true);
      setError("");

      const result = await signIn("credentials", {
        email,
        password,
        redirect: false,
      });

      if (result?.error) {
        setError("Invalid email or password");
        setLoading(false);
      } else {
        router.push("/");
        router.refresh();
      }
    };

    // Render Card with form...
  }
  ```

  Style the card cleanly: white background, subtle shadow, rounded corners. The design should feel professional and simple — remember this is for non-technical team members.
  </action>
  <verify>
  - `npm run build` succeeds with no TypeScript errors
  - `src/server/auth.ts` exports `{ handlers, auth, signIn, signOut }`
  - `src/app/api/auth/[...nextauth]/route.ts` exports GET and POST handlers
  - `src/middleware.ts` exists and protects dashboard routes
  - `src/app/(auth)/login/page.tsx` renders a login form with email and password fields
  - Type extension in `src/types/next-auth.d.ts` adds `role` to Session user
  </verify>
  <done>
  Auth.js v5 configured with Credentials provider, JWT session strategy, and role-based session. Login page at /login with clean card UI. Middleware redirects unauthenticated users to /login. FND-02 (authentication with role assignment) is addressed.
  </done>
</task>

<task type="auto">
  <name>Task 2: tRPC v11 setup with context, routers, and master data CRUD procedures</name>
  <files>
    src/server/api/trpc.ts
    src/server/api/root.ts
    src/server/api/routers/brands.ts
    src/server/api/routers/skus.ts
    src/server/api/routers/retailers.ts
    src/server/api/routers/audit.ts
    src/app/api/trpc/[trpc]/route.ts
    src/lib/trpc.ts
    src/components/providers.tsx
    src/app/layout.tsx
  </files>
  <action>
  **1. Create `src/server/api/trpc.ts`** — tRPC initialization with context:

  ```typescript
  import { initTRPC, TRPCError } from "@trpc/server";
  import { auth } from "@/server/auth";
  import { db } from "@/server/db";

  export const createTRPCContext = async (opts: { headers: Headers }) => {
    const session = await auth();
    return {
      session,
      db,
      ...opts,
    };
  };

  const t = initTRPC.context<typeof createTRPCContext>().create();

  export const router = t.router;
  export const publicProcedure = t.procedure;

  export const protectedProcedure = t.procedure.use(async (opts) => {
    if (!opts.ctx.session?.user) {
      throw new TRPCError({ code: "UNAUTHORIZED" });
    }
    return opts.next({
      ctx: {
        session: { ...opts.ctx.session, user: opts.ctx.session.user },
      },
    });
  });

  // Role-specific procedures
  export const adminProcedure = protectedProcedure.use(async (opts) => {
    const role = opts.ctx.session.user.role;
    if (role !== "ceo" && role !== "admin") {
      throw new TRPCError({ code: "FORBIDDEN", message: "Admin access required" });
    }
    return opts.next();
  });
  ```

  **2. Create `src/server/api/routers/brands.ts`** — Brand CRUD:

  ```typescript
  import { z } from "zod";
  import { router, protectedProcedure, adminProcedure } from "../trpc";
  import { brands } from "@/server/db/schema";
  import { eq } from "drizzle-orm";

  export const brandsRouter = router({
    getAll: protectedProcedure.query(async ({ ctx }) => {
      return ctx.db.query.brands.findMany({
        where: eq(brands.active, true),
        orderBy: (brands, { asc }) => [asc(brands.name)],
        with: { skus: true },
      });
    }),

    getById: protectedProcedure
      .input(z.object({ id: z.number() }))
      .query(async ({ ctx, input }) => {
        return ctx.db.query.brands.findFirst({
          where: eq(brands.id, input.id),
          with: { skus: true },
        });
      }),

    create: adminProcedure
      .input(z.object({
        name: z.string().min(1).max(255),
        description: z.string().optional(),
        leadTimeDays: z.number().int().min(1).default(30),
      }))
      .mutation(async ({ ctx, input }) => {
        const [brand] = await ctx.db.insert(brands).values(input).returning();
        return brand;
      }),

    update: adminProcedure
      .input(z.object({
        id: z.number(),
        name: z.string().min(1).max(255).optional(),
        description: z.string().optional(),
        leadTimeDays: z.number().int().min(1).optional(),
      }))
      .mutation(async ({ ctx, input }) => {
        const { id, ...data } = input;
        const [brand] = await ctx.db.update(brands)
          .set({ ...data, updatedAt: new Date() })
          .where(eq(brands.id, id))
          .returning();
        return brand;
      }),

    // Soft delete only — never hard delete master data
    deactivate: adminProcedure
      .input(z.object({ id: z.number() }))
      .mutation(async ({ ctx, input }) => {
        const [brand] = await ctx.db.update(brands)
          .set({ active: false, updatedAt: new Date() })
          .where(eq(brands.id, input.id))
          .returning();
        return brand;
      }),
  });
  ```

  **3. Create `src/server/api/routers/skus.ts`** — SKU CRUD:

  Similar pattern to brands router. Procedures:
  - `getAll` — protectedProcedure, query all active SKUs with brand relation, supports optional `brandId` filter via input `z.object({ brandId: z.number().optional() })`
  - `getById` — protectedProcedure, single SKU with brand relation
  - `create` — adminProcedure, input: `{ brandId: number, sku: string, name: string, description?: string, category?: string, unitCost?: string, unitPrice?: string }`
  - `update` — adminProcedure, partial update by id
  - `deactivate` — adminProcedure, soft delete

  For the `getAll` query, if `brandId` is provided, filter by it. Use `and()` from drizzle-orm to combine conditions.

  **4. Create `src/server/api/routers/retailers.ts`** — Retailer CRUD:

  Similar pattern. Procedures:
  - `getAll` — protectedProcedure, all active retailers ordered by name
  - `getById` — protectedProcedure, single retailer
  - `create` — adminProcedure, input: `{ name: string, code: string, parentGroup?: string, channel?: string }`
  - `update` — adminProcedure, partial update by id
  - `deactivate` — adminProcedure, soft delete

  **5. Create `src/server/api/routers/audit.ts`** — Audit log viewer:

  ```typescript
  import { z } from "zod";
  import { router, protectedProcedure } from "../trpc";
  import { auditLog } from "@/server/db/schema";
  import { desc, eq, and } from "drizzle-orm";

  export const auditRouter = router({
    getRecent: protectedProcedure
      .input(z.object({
        limit: z.number().int().min(1).max(100).default(50),
        tableName: z.string().optional(),
      }))
      .query(async ({ ctx, input }) => {
        const conditions = input.tableName
          ? eq(auditLog.tableName, input.tableName)
          : undefined;

        return ctx.db.query.auditLog.findMany({
          where: conditions,
          orderBy: [desc(auditLog.createdAt)],
          limit: input.limit,
        });
      }),

    getByRecord: protectedProcedure
      .input(z.object({
        tableName: z.string(),
        recordId: z.string(),
      }))
      .query(async ({ ctx, input }) => {
        return ctx.db.query.auditLog.findMany({
          where: and(
            eq(auditLog.tableName, input.tableName),
            eq(auditLog.recordId, input.recordId),
          ),
          orderBy: [desc(auditLog.createdAt)],
        });
      }),
  });
  ```

  **6. Create `src/server/api/root.ts`** — combine all routers:

  ```typescript
  import { router } from "./trpc";
  import { brandsRouter } from "./routers/brands";
  import { skusRouter } from "./routers/skus";
  import { retailersRouter } from "./routers/retailers";
  import { auditRouter } from "./routers/audit";

  export const appRouter = router({
    brands: brandsRouter,
    skus: skusRouter,
    retailers: retailersRouter,
    audit: auditRouter,
  });

  export type AppRouter = typeof appRouter;
  ```

  **7. Create `src/app/api/trpc/[trpc]/route.ts`** — tRPC HTTP handler:

  ```typescript
  import { fetchRequestHandler } from "@trpc/server/adapters/fetch";
  import { appRouter } from "@/server/api/root";
  import { createTRPCContext } from "@/server/api/trpc";

  const handler = (req: Request) =>
    fetchRequestHandler({
      endpoint: "/api/trpc",
      req,
      router: appRouter,
      createContext: () => createTRPCContext({ headers: req.headers }),
    });

  export { handler as GET, handler as POST };
  ```

  **8. Create `src/lib/trpc.ts`** — tRPC client setup for React:

  Create the tRPC React client using `createTRPCReact` from `@trpc/react-query`.

  ```typescript
  "use client";

  import { createTRPCReact } from "@trpc/react-query";
  import type { AppRouter } from "@/server/api/root";

  export const trpc = createTRPCReact<AppRouter>();
  ```

  **9. Create `src/components/providers.tsx`** — React Query + tRPC provider:

  ```tsx
  "use client";

  import { useState } from "react";
  import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
  import { httpBatchLink } from "@trpc/client";
  import { trpc } from "@/lib/trpc";

  export function Providers({ children }: { children: React.ReactNode }) {
    const [queryClient] = useState(() => new QueryClient());
    const [trpcClient] = useState(() =>
      trpc.createClient({
        links: [
          httpBatchLink({
            url: "/api/trpc",
          }),
        ],
      })
    );

    return (
      <trpc.Provider client={trpcClient} queryClient={queryClient}>
        <QueryClientProvider client={queryClient}>
          {children}
        </QueryClientProvider>
      </trpc.Provider>
    );
  }
  ```

  **10. Update `src/app/layout.tsx`** — wrap app with Providers:

  Read the existing layout.tsx first. Then wrap the `{children}` with `<Providers>`. Import `Providers` from `@/components/providers`. Keep existing HTML structure, fonts, metadata, etc. Just add the provider wrapper inside the `<body>`.

  ```tsx
  import { Providers } from "@/components/providers";

  // ... existing layout code ...
  <body>
    <Providers>
      {children}
    </Providers>
  </body>
  ```
  </action>
  <verify>
  - `npm run build` succeeds with no TypeScript errors
  - `src/server/api/root.ts` exports `appRouter` with brands, skus, retailers, audit routers
  - `src/server/api/trpc.ts` exports `publicProcedure`, `protectedProcedure`, `adminProcedure`
  - `src/app/api/trpc/[trpc]/route.ts` exports GET and POST
  - `src/lib/trpc.ts` exports `trpc` client
  - `src/components/providers.tsx` wraps tRPC + React Query providers
  - `src/app/layout.tsx` includes Providers wrapper
  - All router files use Zod for input validation
  - Brand/SKU/Retailer routers have getAll, getById, create, update, deactivate procedures
  - Audit router has getRecent and getByRecord procedures
  </verify>
  <done>
  tRPC v11 configured with context (session + db), public/protected/admin procedures, and four routers (brands, skus, retailers, audit). React Query + tRPC client provider set up for client components. All CRUD operations use soft deletes for master data. Audit log is queryable via tRPC.
  </done>
</task>

<task type="auto">
  <name>Task 3: PostgreSQL audit triggers and migration</name>
  <files>
    drizzle/migrations/0001_audit_triggers.sql
    src/server/db/seed.ts
  </files>
  <action>
  **1. Create `drizzle/migrations/0001_audit_triggers.sql`** — PostgreSQL audit trigger function:

  This SQL file creates the audit trigger function and attaches it to all master data tables. This runs AFTER the Drizzle schema push (which creates the tables).

  ```sql
  -- Audit trigger function: logs all INSERT, UPDATE, DELETE operations
  CREATE OR REPLACE FUNCTION audit_trigger_func()
  RETURNS TRIGGER AS $$
  BEGIN
    IF TG_OP = 'INSERT' THEN
      INSERT INTO audit_log (table_name, record_id, action, changed_data, created_at)
      VALUES (TG_TABLE_NAME, NEW.id::text, 'INSERT', row_to_json(NEW)::text, NOW());
      RETURN NEW;
    ELSIF TG_OP = 'UPDATE' THEN
      INSERT INTO audit_log (table_name, record_id, action, changed_data, previous_data, created_at)
      VALUES (TG_TABLE_NAME, NEW.id::text, 'UPDATE', row_to_json(NEW)::text, row_to_json(OLD)::text, NOW());
      RETURN NEW;
    ELSIF TG_OP = 'DELETE' THEN
      INSERT INTO audit_log (table_name, record_id, action, previous_data, created_at)
      VALUES (TG_TABLE_NAME, OLD.id::text, 'DELETE', row_to_json(OLD)::text, NOW());
      RETURN OLD;
    END IF;
  END;
  $$ LANGUAGE plpgsql;

  -- Attach triggers to master data tables
  DROP TRIGGER IF EXISTS brands_audit ON brands;
  CREATE TRIGGER brands_audit
    AFTER INSERT OR UPDATE OR DELETE ON brands
    FOR EACH ROW EXECUTE FUNCTION audit_trigger_func();

  DROP TRIGGER IF EXISTS skus_audit ON skus;
  CREATE TRIGGER skus_audit
    AFTER INSERT OR UPDATE OR DELETE ON skus
    FOR EACH ROW EXECUTE FUNCTION audit_trigger_func();

  DROP TRIGGER IF EXISTS retailers_audit ON retailers;
  CREATE TRIGGER retailers_audit
    AFTER INSERT OR UPDATE OR DELETE ON retailers
    FOR EACH ROW EXECUTE FUNCTION audit_trigger_func();

  DROP TRIGGER IF EXISTS brand_retailers_audit ON brand_retailers;
  CREATE TRIGGER brand_retailers_audit
    AFTER INSERT OR UPDATE OR DELETE ON brand_retailers
    FOR EACH ROW EXECUTE FUNCTION audit_trigger_func();

  -- Also attach to transactional tables for completeness
  DROP TRIGGER IF EXISTS purchase_orders_audit ON purchase_orders;
  CREATE TRIGGER purchase_orders_audit
    AFTER INSERT OR UPDATE OR DELETE ON purchase_orders
    FOR EACH ROW EXECUTE FUNCTION audit_trigger_func();

  DROP TRIGGER IF EXISTS forecasts_audit ON forecasts;
  CREATE TRIGGER forecasts_audit
    AFTER INSERT OR UPDATE OR DELETE ON forecasts
    FOR EACH ROW EXECUTE FUNCTION audit_trigger_func();

  DROP TRIGGER IF EXISTS inventory_audit ON inventory;
  CREATE TRIGGER inventory_audit
    AFTER INSERT OR UPDATE OR DELETE ON inventory
    FOR EACH ROW EXECUTE FUNCTION audit_trigger_func();

  DROP TRIGGER IF EXISTS retail_orders_audit ON retail_orders;
  CREATE TRIGGER retail_orders_audit
    AFTER INSERT OR UPDATE OR DELETE ON retail_orders
    FOR EACH ROW EXECUTE FUNCTION audit_trigger_func();

  DROP TRIGGER IF EXISTS payments_audit ON payments;
  CREATE TRIGGER payments_audit
    AFTER INSERT OR UPDATE OR DELETE ON payments
    FOR EACH ROW EXECUTE FUNCTION audit_trigger_func();
  ```

  **2. Create `src/server/db/seed.ts`** — seed script with initial admin user:

  This script creates the initial admin/CEO user so Kaaba can log in. Also creates any default data.

  ```typescript
  import { db, pool } from "./index";
  import { users } from "./schema";
  import bcrypt from "bcryptjs";
  import { eq } from "drizzle-orm";
  import { readFileSync } from "fs";
  import { join } from "path";

  async function main() {
    console.log("Seeding database...");

    // 1. Create admin/CEO user
    const existingUser = await db.query.users.findFirst({
      where: eq(users.email, "kaaba@petrograms.com"),
    });

    if (!existingUser) {
      const passwordHash = await bcrypt.hash("admin123", 12);
      await db.insert(users).values({
        id: crypto.randomUUID(),
        name: "Kaaba",
        email: "kaaba@petrograms.com",
        passwordHash,
        role: "ceo",
        active: true,
      });
      console.log("Created admin user: kaaba@petrograms.com / admin123");
    } else {
      console.log("Admin user already exists, skipping");
    }

    // 2. Run audit trigger migration
    try {
      const triggerSql = readFileSync(
        join(process.cwd(), "drizzle/migrations/0001_audit_triggers.sql"),
        "utf-8"
      );
      await pool.query(triggerSql);
      console.log("Audit triggers installed");
    } catch (err) {
      console.log("Audit triggers may already exist:", (err as Error).message);
    }

    console.log("Seeding complete!");
    await pool.end();
    process.exit(0);
  }

  main().catch((err) => {
    console.error("Seed failed:", err);
    process.exit(1);
  });
  ```

  **3. Add `tsx` to dev dependencies** if not already present (needed for `npm run db:seed`):
  ```bash
  npm install -D tsx
  ```

  **4. Verify the seed script runs:**
  ```bash
  npm run db:push && npm run db:seed
  ```
  (This requires a running PostgreSQL database. If none exists, note in verification.)
  </action>
  <verify>
  - `drizzle/migrations/0001_audit_triggers.sql` exists and contains audit_trigger_func
  - SQL file creates triggers for: brands, skus, retailers, brand_retailers, purchase_orders, forecasts, inventory, retail_orders, payments
  - `src/server/db/seed.ts` exists and creates initial CEO user with hashed password
  - Seed script reads and executes the audit trigger SQL
  - `npm run build` still succeeds
  - If PostgreSQL is available: `npm run db:push && npm run db:seed` runs without errors
  </verify>
  <done>
  PostgreSQL audit triggers installed on all critical tables (brands, skus, retailers, brand_retailers, purchase_orders, forecasts, inventory, retail_orders, payments). Initial CEO user created (kaaba@petrograms.com). FND-02 (authentication) and FND-04 (audit logging) are fully addressed. The seed script serves as the bootstrap for the database.
  </done>
</task>

</tasks>

<verification>
- [ ] `npm run build` succeeds with no TypeScript errors
- [ ] Auth.js v5 configured with Credentials provider and JWT strategy
- [ ] Login page renders at /login with email and password fields
- [ ] Middleware redirects unauthenticated users to /login
- [ ] Session includes user role in JWT token
- [ ] tRPC context includes session and db
- [ ] Protected procedures reject unauthenticated requests
- [ ] Admin procedures reject non-CEO/admin users
- [ ] Brands, SKUs, Retailers routers have full CRUD (getAll, getById, create, update, deactivate)
- [ ] Audit router provides getRecent and getByRecord queries
- [ ] PostgreSQL audit triggers defined for 9 tables
- [ ] Seed script creates CEO user and installs triggers
- [ ] React Query + tRPC client provider wraps the app
</verification>

<success_criteria>
- Users can log in with email/password via /login (FND-02)
- Logged-in users have role available in session (FND-02)
- Unauthenticated access redirects to /login
- tRPC API provides type-safe CRUD for brands, skus, retailers
- Master data operations are soft-delete only
- PostgreSQL audit triggers capture all changes to master data tables (FND-04)
- Initial admin user exists for first login
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-master-data/01-02-SUMMARY.md`
</output>
