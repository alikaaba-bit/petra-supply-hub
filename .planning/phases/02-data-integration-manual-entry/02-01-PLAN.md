---
phase: 02-data-integration-manual-entry
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - next.config.ts
  - src/components/ui/scroll-area.tsx
  - src/components/ui/progress.tsx
  - src/components/ui/select.tsx
  - src/server/services/parsers/format-detector.ts
  - src/server/services/parsers/rtl-forecast.ts
  - src/server/services/parsers/hop-forecast.ts
  - src/server/services/parsers/retail-sales.ts
  - src/server/services/validators/forecast-validator.ts
  - src/server/services/validators/sales-validator.ts
  - src/server/services/import-service.ts
  - src/server/actions/import-forecast.ts
  - src/server/actions/import-sales.ts
  - src/server/api/routers/import.ts
  - src/server/api/routers/orders.ts
  - src/server/api/root.ts
  - src/server/db/schema.ts
autonomous: true

must_haves:
  truths:
    - "Excel files in RTL FORECAST_MASTER format can be parsed into structured forecast rows with SKU, retailer, month, and units"
    - "Excel files in HOP product-centric format can be parsed into the same structured forecast rows"
    - "Retail sales Excel files can be parsed into SKU performance rows"
    - "Parsed rows are validated against master data (existing SKUs and retailers) with row-level error and warning collection"
    - "Valid forecast rows can be upserted into the forecasts table using (skuId, retailerId, month) conflict target"
    - "Server Actions accept FormData file uploads up to 10MB"
    - "Purchase orders and retail orders can be created and listed via tRPC"
  artifacts:
    - path: "src/server/services/parsers/format-detector.ts"
      provides: "detectFormat function returning RTL_FORECAST | HOP_FORECAST | RETAIL_SALES"
      exports: ["detectFormat", "ExcelFormat"]
    - path: "src/server/services/parsers/rtl-forecast.ts"
      provides: "RTL FORECAST_MASTER Excel parser"
      exports: ["parseRTLForecast"]
    - path: "src/server/services/parsers/hop-forecast.ts"
      provides: "HOP product-centric Excel parser"
      exports: ["parseHOPForecast"]
    - path: "src/server/services/parsers/retail-sales.ts"
      provides: "Retail sales Excel parser"
      exports: ["parseRetailSales"]
    - path: "src/server/services/validators/forecast-validator.ts"
      provides: "Zod validation for forecast rows against master data"
      exports: ["validateForecastRows", "ValidationResult"]
    - path: "src/server/services/validators/sales-validator.ts"
      provides: "Zod validation for retail sales rows"
      exports: ["validateSalesRows"]
    - path: "src/server/services/import-service.ts"
      provides: "Batch upsert for forecasts and sales data"
      exports: ["importForecasts", "importRetailSales"]
    - path: "src/server/actions/import-forecast.ts"
      provides: "Server Action for forecast file upload, parse, validate"
      exports: ["parseAndValidateForecast", "commitForecastImport"]
    - path: "src/server/actions/import-sales.ts"
      provides: "Server Action for retail sales file upload, parse, validate"
      exports: ["parseAndValidateSales", "commitSalesImport"]
    - path: "src/server/api/routers/orders.ts"
      provides: "tRPC router for purchase orders and retail orders CRUD"
      exports: ["ordersRouter"]
    - path: "src/server/api/routers/import.ts"
      provides: "tRPC router for import history and forecast queries"
      exports: ["importRouter"]
  key_links:
    - from: "src/server/actions/import-forecast.ts"
      to: "src/server/services/parsers/format-detector.ts"
      via: "detectFormat call"
      pattern: "detectFormat\\(workbook\\)"
    - from: "src/server/services/validators/forecast-validator.ts"
      to: "src/server/db/schema.ts"
      via: "query existing SKUs and retailers"
      pattern: "db\\.select.*from\\(skus\\)"
    - from: "src/server/services/import-service.ts"
      to: "src/server/db/schema.ts"
      via: "batch upsert into forecasts table"
      pattern: "onConflictDoUpdate"
    - from: "src/server/api/root.ts"
      to: "src/server/api/routers/orders.ts"
      via: "router registration"
      pattern: "orders:\\s*ordersRouter"
---

<objective>
Install dependencies and build the complete server-side Excel parsing, validation, and import infrastructure for Phase 2.

Purpose: This plan creates all backend services needed for Excel import (forecast + retail sales) and order management. No UI is built here -- this is pure server-side infrastructure that Plan 02 (import wizard) and Plan 03 (manual entry) will consume.

Output: ExcelJS parsers for 3 formats, Zod validators, batch upsert service, Server Actions for file upload, tRPC routers for orders and import queries. The `npm run build` must pass with all new code.
</objective>

<execution_context>
@/Users/kaaba/.claude/get-shit-done/workflows/execute-plan.md
@/Users/kaaba/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-data-integration-manual-entry/02-RESEARCH.md

Key source files to reference:
@src/server/db/schema.ts — All 16 tables with forecasts, purchaseOrders, poLineItems, retailOrders, retailOrderLineItems schemas
@src/server/api/trpc.ts — protectedProcedure, publicProcedure, adminProcedure patterns
@src/server/api/routers/brands.ts — Router pattern to follow (count, list, getById, create, update, delete)
@src/server/api/root.ts — Where to register new routers
@src/server/db/index.ts — Database connection (import { db })
@next.config.ts — Needs bodySizeLimit update
@package.json — Current dependencies
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install dependencies, configure Next.js, and install shadcn components</name>
  <files>
    package.json
    next.config.ts
    src/components/ui/scroll-area.tsx
    src/components/ui/progress.tsx
    src/components/ui/select.tsx
  </files>
  <action>
    1. Install required dependencies:
       `npm install exceljs react-hook-form @hookform/resolvers react-dropzone`

    2. Install shadcn/ui components needed by Plans 02 and 03 (installing here in Wave 1 so both Wave 2 plans can use them):
       `npx shadcn@latest add scroll-area progress select`

    3. Update `next.config.ts` to increase Server Actions body size limit:
       ```typescript
       import type { NextConfig } from "next";

       const nextConfig: NextConfig = {
         experimental: {
           serverActions: {
             bodySizeLimit: "10mb",
           },
         },
       };

       export default nextConfig;
       ```

    4. Verify installation succeeded and lock file updated.
  </action>
  <verify>`npm run build` does not error on config. Check `node_modules/exceljs` exists. Check `node_modules/react-dropzone` exists. Check `ls src/components/ui/scroll-area.tsx src/components/ui/progress.tsx src/components/ui/select.tsx` all exist.</verify>
  <done>package.json has exceljs, react-hook-form, @hookform/resolvers, react-dropzone in dependencies. next.config.ts has bodySizeLimit: "10mb". shadcn scroll-area, progress, select components installed.</done>
</task>

<task type="auto">
  <name>Task 2: Create Excel parsers and format detector</name>
  <files>
    src/server/services/parsers/format-detector.ts
    src/server/services/parsers/rtl-forecast.ts
    src/server/services/parsers/hop-forecast.ts
    src/server/services/parsers/retail-sales.ts
  </files>
  <action>
    Create all 4 parser files. Follow the architecture from 02-RESEARCH.md.

    **A. Format Detector** (`src/server/services/parsers/format-detector.ts`):
    - Export `type ExcelFormat = 'RTL_FORECAST' | 'HOP_FORECAST' | 'RETAIL_SALES'`
    - Export `function detectFormat(workbook: ExcelJS.Workbook): ExcelFormat`
    - RTL detection: worksheets have names matching pattern like "Jan 2026 PO", "Feb 2026 PO" (monthly PO sheets). Look for sheet names containing month abbreviations AND "PO".
    - HOP detection: single or few sheets, first column header is "Product" or "Item", subsequent columns are retailer names. No monthly PO sheet pattern.
    - RETAIL_SALES detection: headers include "SKU" AND ("Units Sold" or "Revenue" or "Sales").
    - Throw descriptive error if no format matched.

    **B. RTL FORECAST_MASTER Parser** (`src/server/services/parsers/rtl-forecast.ts`):
    - Export `type ParsedForecastRow = { sku: string; retailer: string; month: Date; forecastedUnits: number; rowNumber: number; sheetName: string }`
    - Export `function parseRTLForecast(workbook: ExcelJS.Workbook): ParsedForecastRow[]`
    - Filter worksheets to those matching monthly PO pattern (e.g., "Jan 2026 PO", "Feb 2026 PO").
    - For each PO sheet:
      - Extract month/year from sheet name using regex: `/(\w{3})\s+(\d{4})/`
      - Row 1 is headers. Column 1 is "Retailer" (or similar). Remaining columns are SKU codes.
      - Iterate data rows (row 2+). Column 1 = retailer name. Each SKU column = forecasted units for that retailer/SKU/month.
      - Skip rows where retailer is empty. Skip cells where value is 0, empty, or non-numeric.
      - Include rowNumber and sheetName for error reporting.
    - Handle ExcelJS cell types properly: `cell.type === ExcelJS.ValueType.Number` for units.
    - Parse month from sheet name into Date object (first day of month): `new Date(year, monthIndex, 1)`.

    **C. HOP Forecast Parser** (`src/server/services/parsers/hop-forecast.ts`):
    - Export `function parseHOPForecast(workbook: ExcelJS.Workbook): ParsedForecastRow[]`
    - HOP format is product-centric: products in rows, retailers as column groups.
    - Row 1 headers: first col = "Product"/"Item"/"SKU", then retailer names with monthly sub-columns.
    - Since exact format is unknown (per research open question), implement a flexible parser:
      - Read row 1 for column headers.
      - Identify the product/SKU column (first text column).
      - Remaining columns are retailer-month pairs. Try to detect retailer names and months from headers.
      - If headers have structure like "RetailerName - Jan 2026", parse retailer and month.
      - If simpler (just retailer names with no months), assume current forecast period.
    - Add a comment noting this parser may need adjustment when real HOP files are available.
    - Return same `ParsedForecastRow[]` type as RTL parser.

    **D. Retail Sales Parser** (`src/server/services/parsers/retail-sales.ts`):
    - Export `type ParsedSalesRow = { sku: string; retailer: string; month: Date; unitsSold: number; revenue: number | null; rowNumber: number }`
    - Export `function parseRetailSales(workbook: ExcelJS.Workbook): ParsedSalesRow[]`
    - Expected columns (case-insensitive header matching): SKU, Retailer, Month/Date/Period, Units Sold/Qty Sold, Revenue/Sales Amount (optional).
    - Map header names to field names using a flexible header matcher (normalize to lowercase, trim, match known aliases).
    - Iterate data rows, parse each cell by column mapping.
    - Handle date cells (ExcelJS date type or string dates).
    - Skip empty rows.

    **Important implementation notes:**
    - Use `import ExcelJS from 'exceljs'` (default import).
    - ExcelJS cell values accessed via `cell.value`. Check `cell.type` for type safety using `ExcelJS.ValueType.Number`, `ExcelJS.ValueType.String`, `ExcelJS.ValueType.Date`.
    - For headerRow.values in ExcelJS, index 0 is undefined (ExcelJS is 1-indexed). Account for this.
    - The `ParsedForecastRow` type is defined in `rtl-forecast.ts` and re-exported for use by other files.
    - The `ParsedSalesRow` type is defined in `retail-sales.ts` and re-exported for use by other files.
  </action>
  <verify>
    1. `npm run build` passes with no TypeScript errors.
    2. All parser files exist: `ls src/server/services/parsers/format-detector.ts src/server/services/parsers/rtl-forecast.ts src/server/services/parsers/hop-forecast.ts src/server/services/parsers/retail-sales.ts`
    3. `grep "detectFormat" src/server/services/parsers/format-detector.ts` confirms format detection.
  </verify>
  <done>4 parser files created: format detector routing RTL/HOP/RETAIL_SALES, RTL forecast parser, HOP forecast parser, retail sales parser. All compile.</done>
</task>

<task type="auto">
  <name>Task 3: Create validators, import service, and Server Actions</name>
  <files>
    src/server/services/validators/forecast-validator.ts
    src/server/services/validators/sales-validator.ts
    src/server/services/import-service.ts
    src/server/actions/import-forecast.ts
    src/server/actions/import-sales.ts
  </files>
  <action>
    Create validators, batch import service, and Server Actions for file upload.

    **A. Forecast Validator** (`src/server/services/validators/forecast-validator.ts`):
    - Export `type ValidationError = { row: number; field: string; message: string; sheet?: string }`
    - Export `type ValidationWarning = { row: number; message: string; sheet?: string }`
    - Export `type ValidationResult<T> = { valid: T[]; errors: ValidationError[]; warnings: ValidationWarning[]; summary: { totalRows: number; validRows: number; errorRows: number; warningRows: number } }`
    - Export `type ValidatedForecastRow` which has: `skuId: number; retailerId: number; sku: string; retailer: string; month: Date; forecastedUnits: number; rowNumber: number; sheetName: string`
    - Export `async function validateForecastRows(rows: ParsedForecastRow[]): Promise<ValidationResult<ValidatedForecastRow>>`
    - Query database ONCE for all SKUs (`db.select({ sku: skus.sku, id: skus.id }).from(skus)`) and build a Map.
    - Query database ONCE for all retailers (`db.select({ name: retailers.name, id: retailers.id }).from(retailers)`) and build a Map.
    - For each row:
      - Validate SKU exists in master data (case-insensitive match). Error if not found.
      - Validate retailer exists in master data (case-insensitive match). Hard error if not found.
      - Validate month is a valid date within 2 years of today.
      - Validate forecastedUnits is positive integer.
      - Check for duplicate (sku + retailer + month) within the import batch. Warn on duplicates (later row wins).
    - Return ValidationResult with summary counts.

    **B. Sales Validator** (`src/server/services/validators/sales-validator.ts`):
    - Export `type ValidatedSalesRow` with resolved `skuId` and `retailerId`.
    - Export `async function validateSalesRows(rows: ParsedSalesRow[]): Promise<ValidationResult<ValidatedSalesRow>>`
    - Same pattern as forecast validator but for sales data.
    - Validate SKU exists, retailer exists, unitsSold >= 0, month is valid date.
    - Revenue can be null (optional field).

    **C. Import Service** (`src/server/services/import-service.ts`):
    - Export `async function importForecasts(rows: ValidatedForecastRow[], userId: string): Promise<{ imported: number; updated: number }>`
      - Use `db.insert(forecasts).values(records).onConflictDoUpdate()` on the existing unique constraint `sku_retailer_month_unique` (skuId, retailerId, month).
      - On conflict, update `forecastedUnits`, `source` (set to 'excel_import'), `updatedAt`.
      - Set `createdBy` to userId, `source` to 'excel_import'.
      - Process in batches of 100 rows to avoid oversized queries.
      - Return count of imported and updated rows.
    - Export `async function importRetailSales(rows: ValidatedSalesRow[], userId: string): Promise<{ imported: number }>`
      - Insert into the `retailSales` table (added in Task 4).
      - Use `onConflictDoUpdate` on (skuId, retailerId, month) unique constraint.
      - Process in batches of 100.
    - The `sql` import from drizzle-orm is needed for `onConflictDoUpdate` set clauses.

    **D. Import Forecast Server Action** (`src/server/actions/import-forecast.ts`):
    - `'use server'` directive at top.
    - Export `async function parseAndValidateForecast(formData: FormData)`:
      - Get file from formData, validate size (10MB max), validate MIME type (.xlsx only).
      - Validate .xlsx file signature (first 4 bytes = 504b0304).
      - Parse with ExcelJS: `const workbook = new ExcelJS.Workbook(); await workbook.xlsx.load(buffer)`.
      - Detect format with `detectFormat(workbook)`. If RETAIL_SALES, throw error ("Use retail sales import for this file").
      - Route to `parseRTLForecast` or `parseHOPForecast` based on detected format.
      - Validate with `validateForecastRows`.
      - **IMPORTANT - Serialization**: Server Actions return data over the wire as JSON. Convert Date objects to ISO strings before returning. Return type should have `month: string` (ISO string) not `month: Date`.
      - Return `{ success: boolean; format: ExcelFormat; validation: { valid: SerializedForecastRow[]; errors; warnings; summary }; previewData: SerializedForecastRow[] }` (first 100 rows for preview).
      - Do NOT commit to database -- this is preview only.
    - Export `async function commitForecastImport(rows: SerializedForecastRow[])`:
      - Auth check: `const session = await auth(); if (!session?.user) throw new Error('Unauthorized')`.
      - **IMPORTANT - Security**: Re-validate that all skuId and retailerId values exist in the database before importing. The client could have tampered with the validated data. Query DB for valid IDs and filter out any rows with invalid references.
      - **IMPORTANT - Deserialization**: Convert `month` from ISO string back to Date before passing to importForecasts.
      - Call `importForecasts(deserializedRows, session.user.id)`.
      - Return `{ success: true, imported: result.imported, updated: result.updated }`.
    - Define `type SerializedForecastRow = Omit<ValidatedForecastRow, 'month'> & { month: string }` for the wire format.

    **E. Import Sales Server Action** (`src/server/actions/import-sales.ts`):
    - Same pattern as import-forecast but for retail sales.
    - `parseAndValidateSales(formData: FormData)`: parse file, detect format (must be RETAIL_SALES), validate, return preview with serialized dates.
    - `commitSalesImport(rows: SerializedSalesRow[])`: auth check, re-validate IDs against DB, deserialize dates, call `importRetailSales`, return result.
  </action>
  <verify>
    1. `npm run build` passes with no TypeScript errors.
    2. All files exist: `ls src/server/services/validators/ src/server/services/import-service.ts src/server/actions/`
    3. `grep "onConflictDoUpdate" src/server/services/import-service.ts` confirms upsert logic exists.
    4. `grep "re-validate\|Re-validate\|skuId.*exists\|valid.*IDs" src/server/actions/import-forecast.ts` confirms security re-validation in commit action.
  </verify>
  <done>Validators, import service, and Server Actions created with proper serialization and security re-validation. Build passes.</done>
</task>

<task type="auto">
  <name>Task 4: Create tRPC routers and update schema</name>
  <files>
    src/server/api/routers/import.ts
    src/server/api/routers/orders.ts
    src/server/api/root.ts
    src/server/db/schema.ts
  </files>
  <action>
    Create tRPC routers for import queries and order management, register them, and add retailSales table.

    **A. Import Router** (`src/server/api/routers/import.ts`):
    - tRPC router for querying imported data.
    - `forecasts.list`: protectedProcedure, optional filters (brandId, retailerId, month range). Query forecasts with joins to skus and retailers. Return forecast rows with sku.name, sku.sku, retailer.name.
    - `forecasts.count`: publicProcedure, return total forecast count.
    - `forecasts.byBrand`: protectedProcedure, input brandId. Query forecasts where sku.brandId = brandId, group by month.
    - `retailSales.list`: protectedProcedure, optional filters. Query retail sales with joins.
    - `retailSales.count`: publicProcedure, return count.

    **B. Orders Router** (`src/server/api/routers/orders.ts`):
    - tRPC router for purchase orders and retail orders CRUD.
    - Follow the same pattern as brands.ts router.
    - Purchase Orders:
      - `purchaseOrders.count`: publicProcedure, return count.
      - `purchaseOrders.list`: protectedProcedure, optional filters (brandId, status). Query with brand join. Order by createdAt desc.
      - `purchaseOrders.getById`: protectedProcedure, input id. Query with lineItems (including sku join) and payments.
      - `purchaseOrders.create`: protectedProcedure, input { poNumber, brandId, supplier?, status?, orderDate?, expectedArrival?, totalAmount?, currency?, depositAmount?, depositPaid?, notes?, lineItems: { skuId, quantity, unitCost? }[] }. Insert PO + line items in a transaction. Auto-calculate line item totalCost = quantity * unitCost. Set createdBy.
      - `purchaseOrders.update`: protectedProcedure, input { id, ...updateable fields }. Update PO, set updatedAt.
      - `purchaseOrders.delete`: protectedProcedure, input id. Delete (cascades to line items).
    - Retail Orders:
      - `retailOrders.count`: publicProcedure, return count.
      - `retailOrders.list`: protectedProcedure, optional filters (retailerId, brandId, status). Query with retailer and brand joins. Order by createdAt desc.
      - `retailOrders.getById`: protectedProcedure, input id. Query with lineItems (including sku join).
      - `retailOrders.create`: protectedProcedure, input { retailerPoNumber?, retailerId, brandId, status?, orderDate?, shipByDate?, totalAmount?, notes?, lineItems: { skuId, quantity, unitPrice? }[] }. Insert order + line items in transaction. Auto-calculate totalPrice = quantity * unitPrice. Set createdBy.
      - `retailOrders.update`: protectedProcedure, input { id, ...updateable fields }. Update order, set updatedAt.
      - `retailOrders.delete`: protectedProcedure, input id. Delete (cascades).

    **C. Register Routers** (update `src/server/api/root.ts`):
    - Import `importRouter` from `./routers/import`.
    - Import `ordersRouter` from `./routers/orders`.
    - Add to appRouter: `import: importRouter, orders: ordersRouter`.

    **D. Add retailSales table to schema** (update `src/server/db/schema.ts`):
    - Add after the forecasts section:
      ```typescript
      export const retailSales = pgTable(
        "retail_sales",
        {
          id: serial("id").primaryKey(),
          skuId: integer("sku_id").notNull().references(() => skus.id),
          retailerId: integer("retailer_id").notNull().references(() => retailers.id),
          month: date("month", { mode: "date" }).notNull(),
          unitsSold: integer("units_sold").notNull().default(0),
          revenue: numeric("revenue", { precision: 12, scale: 2 }),
          source: varchar("source", { length: 50 }).default("manual"),
          notes: text("notes"),
          createdBy: text("created_by").references(() => users.id),
          createdAt: timestamp("created_at", { mode: "date" }).notNull().defaultNow(),
          updatedAt: timestamp("updated_at", { mode: "date" }).notNull().defaultNow(),
        },
        (table) => ({
          skuRetailerMonthUnique: unique("retail_sales_sku_retailer_month_unique").on(
            table.skuId, table.retailerId, table.month
          ),
          skuIdIdx: index("retail_sales_sku_id_idx").on(table.skuId),
          retailerIdIdx: index("retail_sales_retailer_id_idx").on(table.retailerId),
          monthIdx: index("retail_sales_month_idx").on(table.month),
        })
      );
      ```
    - Add relations for retailSales (same pattern as forecasts: sku, retailer, createdByUser).
    - Add `retailSales: many(retailSales)` to skusRelations and retailersRelations.

    **Important implementation notes:**
    - Use `db.transaction()` for multi-table inserts in orders router.
    - After adding retailSales table, `npm run db:push` will be needed (document in verify, don't run automatically since DB might not be available).
  </action>
  <verify>
    1. `npm run build` passes with no TypeScript errors.
    2. `grep "import:" src/server/api/root.ts` confirms import router registered.
    3. `grep "orders:" src/server/api/root.ts` confirms orders router registered.
    4. `grep "retail_sales" src/server/db/schema.ts` confirms new table added.
  </verify>
  <done>
    Import router (forecast + sales queries), orders router (PO + retail order CRUD), both registered in root.ts. retailSales table added to schema. Build passes.
  </done>
</task>

</tasks>

<verification>
1. `npm run build` completes without errors (TypeScript compilation passes)
2. All service files exist under `src/server/services/`
3. All Server Action files exist under `src/server/actions/`
4. Import and orders routers registered in root router
5. Schema updated with retailSales table
6. No circular dependencies (build would catch this)
</verification>

<success_criteria>
- ExcelJS installed and importable
- Format detection routes to correct parser
- RTL and HOP parsers produce ParsedForecastRow arrays
- Retail sales parser produces ParsedSalesRow arrays
- Validators check rows against master data (SKUs, retailers) and return structured errors/warnings
- Import service uses onConflictDoUpdate for upsert on (skuId, retailerId, month)
- Server Actions handle FormData with file validation (size, type, signature)
- Orders router supports full CRUD for both purchase orders and retail orders with line items
- next.config.ts has 10MB body size limit for Server Actions
- Build passes with zero errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-data-integration-manual-entry/02-01-SUMMARY.md`
</output>
